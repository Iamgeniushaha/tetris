<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>tetris.io</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <script src="/socket.io/socket.io.js"></script>
<!--    <script src="../all_in_one_tetris.js"></script>-->
    <style>
        html {
            touch-action: manipulation;
            background-image: linear-gradient(175deg, #779ccc, #e9c2f4);
            width: 100vw;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .wrapper-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 30px;
            margin-top: 30px;
            left: -50px;
        }

        .tetris-container {
            display: flex;
            flex-direction: row;
            margin: 10px;
            background-color: #ffffff;
            position: relative;
            top: 0px;
            width: 50%;
            height: 50%;
        }

        .tetris-panel-container {
            display: flex;
            padding-left: 10px;
            padding-right: 10px;
            flex-direction: column;
            color: white;
            background-color: #333333;
            width: 100%;
            height: 100%;
        }

        .tetris-panel-container p {
            margin: 0;
            padding: 0;
        }

        /* 게이지 스타일 */
        .gauge-container {
            position: absolute;
            width: 2vw;
            height: 50vh;
            border: 1px solid #000;
            border-radius: 10px;
            background-color: #ddd;
            overflow: hidden;
        }

        .gauge-container.left {
            left: 2vw;
            top: 25vh;
        }

        .gauge-container.right {
            right: 2vw;
            top: 25vh;
        }

        .gauge-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
            background-color: red;
            transition: height 0.3s ease, background-color 0.3s ease;
        }
    </style>
</head>
<body>

<!-- 좌측 게이지 -->
<div class="gauge-container left">
    <div class="gauge-fill" id="player1_fill"></div>
</div>

<!-- 우측 게이지 -->
<div class="gauge-container right">
    <div class="gauge-fill" id="player2_fill"></div>
</div>

<!-- 테트리스 게임 UI -->
<div class="wrapper-container">
    <span class="tetris-container">
        <canvas id="stage" width="300%" height="600%" style="background-color:black; left: -100%;"></canvas>
        <span class="tetris-panel-container">
            <p>Next:</p>
            <canvas id="next" width="150%" height="150%" style="background-color:black;"></canvas>
            <p>LINES:<span id="lines">0</span></p>
            <p><span id="message"></span></p>
        </span>
    </span>
</div>

<script>
    const token = localStorage.getItem("token");

    if (!token) {
        alert('로그인이 필요합니다');
        window.location.href = '/login';
    } else {
        const socket = io({
            auth: { token },
            transports: ['websocket'], // 명시적으로 설정 권장
        });

        socket.on("connect", () => {
            console.log("소켓 연결 성공!");
        });

        socket.on("connect_error", (err) => {
            console.error("소켓 연결 실패:", err.message);
        });

        // 이후 socket 사용 코드들 작성
        const path = window.location.pathname; // "/room=abcd/game"
        const roomId = path.split('/')[1].split('=')[1]; // "abcd"

        console.log(roomId);
        socket.emit("joinRoom", { roomId });


        function getGaugeColor(percent) {
            if (percent >= 50) {
                const ratio = (percent - 50) / 50;
                const r = Math.round(255 * (1 - ratio));
                const g = Math.round(165 + (240 - 165) * ratio);
                return `rgb(${r},${g},0)`;
            } else {
                const ratio = percent / 50;
                const g = Math.round(165 * ratio);
                return `rgb(255,${g},0)`;
            }
        }

        function setGauge(player, percent) {
            const fill = document.getElementById(player + '_fill');
            fill.style.height = percent + '%';
            fill.style.backgroundColor = getGaugeColor(percent);
        }

        function check_health(player, health) {
            if(health <= 0) {
                socket.emit("gameover", {player});
                gameover();

            }
        }
        function gameover(){

        }

        // 예시: 게이지 수동 조정
        let player1_health = 100;
        let player2_health = 100;
        setGauge("player1", player1_health);
        setGauge("player2", player2_health);

        class Tetris {
            constructor() {
                this.blockQueue = this.shuffleBlocks(); // 초기 블록 큐 생성
                this.stageWidth = 10;
                this.stageHeight = 20;
                this.stageCanvas = document.getElementById("stage");
                this.nextCanvas = document.getElementById("next");
                let cellWidth = this.stageCanvas.width / this.stageWidth;
                let cellHeight = this.stageCanvas.height / this.stageHeight;
                this.cellSize = cellWidth < cellHeight ? cellWidth : cellHeight;
                this.stageLeftPadding = (this.stageCanvas.width - this.cellSize * this.stageWidth) / 2;
                this.stageTopPadding = (this.stageCanvas.height - this.cellSize * this.stageHeight) / 2;
                this.blocks = this.createBlocks();
                this.deletedLines = 0;
                this.blockQueue = this.shuffleBlocks(); // 초기 블록 큐 생성

                window.onkeydown = (e) => {
                    if (e.keyCode === 37) {
                        this.moveLeft();
                    } else if (e.keyCode === 38) {
                        this.rotate();
                    } else if (e.keyCode === 39) {
                        this.moveRight();
                    } else if (e.keyCode === 40) {
                        this.fall();
                    } else if(e.keyCode === 32){
                        this.fall();
                    }
                }
            }

            createBlocks() {
                let blocks = [
                    {
                        shape: [[[-1, 0], [0, 0], [1, 0], [2, 0]],
                            [[0, -1], [0, 0], [0, 1], [0, 2]],
                            [[-1, 0], [0, 0], [1, 0], [2, 0]],
                            [[0, -1], [0, 0], [0, 1], [0, 2]]],
                        color: "rgb(0, 255, 255)",
                        highlight: "rgb(255, 255, 255)",
                        shadow: "rgb(0, 128, 128)"
                    },
                    {
                        shape: [[[0, 0], [1, 0], [0, 1], [1, 1]],
                            [[0, 0], [1, 0], [0, 1], [1, 1]],
                            [[0, 0], [1, 0], [0, 1], [1, 1]],
                            [[0, 0], [1, 0], [0, 1], [1, 1]]],
                        color: "rgb(255, 255, 0)",
                        highlight: "rgb(255, 255, 255)",
                        shadow: "rgb(128, 128, 0)"
                    },
                    {
                        shape: [[[0, 0], [1, 0], [-1, 1], [0, 1]],
                            [[-1, -1], [-1, 0], [0, 0], [0, 1]],
                            [[0, 0], [1, 0], [-1, 1], [0, 1]],
                            [[-1, -1], [-1, 0], [0, 0], [0, 1]]],
                        color: "rgb(0, 255, 0)",
                        highlight: "rgb(255, 255, 255)",
                        shadow: "rgb(0, 128, 0)"
                    },
                    {
                        shape: [[[-1, 0], [0, 0], [0, 1], [1, 1]],
                            [[0, -1], [-1, 0], [0, 0], [-1, 1]],
                            [[-1, 0], [0, 0], [0, 1], [1, 1]],
                            [[0, -1], [-1, 0], [0, 0], [-1, 1]]],
                        color: "rgb(255, 0, 0)",
                        highlight: "rgb(255, 255, 255)",
                        shadow: "rgb(128, 0, 0)"
                    },
                    {
                        shape: [[[-1, -1], [-1, 0], [0, 0], [1, 0]],
                            [[0, -1], [1, -1], [0, 0], [0, 1]],
                            [[-1, 0], [0, 0], [1, 0], [1, 1]],
                            [[0, -1], [0, 0], [-1, 1], [0, 1]]],
                        color: "rgb(0, 0, 255)",
                        highlight: "rgb(255, 255, 255)",
                        shadow: "rgb(0, 0, 128)"
                    },
                    {
                        shape: [[[1, -1], [-1, 0], [0, 0], [1, 0]],
                            [[0, -1], [0, 0], [0, 1], [1, 1]],
                            [[-1, 0], [0, 0], [1, 0], [-1, 1]],
                            [[-1, -1], [0, -1], [0, 0], [0, 1]]],
                        color: "rgb(255, 165, 0)",
                        highlight: "rgb(255, 255, 255)",
                        shadow: "rgb(128, 82, 0)"
                    },
                    {
                        shape: [[[0, -1], [-1, 0], [0, 0], [1, 0]],
                            [[0, -1], [0, 0], [1, 0], [0, 1]],
                            [[-1, 0], [0, 0], [1, 0], [0, 1]],
                            [[0, -1], [-1, 0], [0, 0], [0, 1]]],
                        color: "rgb(255, 0, 255)",
                        highlight: "rgb(255, 255, 255)",
                        shadow: "rgb(128, 0, 128)"
                    }
                ];
                return blocks;
            }

            drawBlock(x, y, type, angle, canvas) {
                let context = canvas.getContext("2d");
                let block = this.blocks[type];
                for (let i = 0; i < block.shape[angle].length; i++) {
                    this.drawCell(context,
                        x + (block.shape[angle][i][0] * this.cellSize),
                        y + (block.shape[angle][i][1] * this.cellSize),
                        this.cellSize,
                        type);
                }
            }

            drawCell(context, cellX, cellY, cellSize, type) {
                let block = this.blocks[type];
                let adjustedX = cellX + 0.5;
                let adjustedY = cellY + 0.5;
                let adjustedSize = cellSize - 1;
                context.fillStyle = block.color;
                context.fillRect(adjustedX, adjustedY, adjustedSize, adjustedSize);
                context.strokeStyle = block.highlight;
                context.beginPath();
                context.moveTo(adjustedX, adjustedY + adjustedSize);
                context.lineTo(adjustedX, adjustedY);
                context.lineTo(adjustedX + adjustedSize, adjustedY);
                context.stroke();
                context.strokeStyle = block.shadow;
                context.beginPath();
                context.moveTo(adjustedX, adjustedY + adjustedSize);
                context.lineTo(adjustedX + adjustedSize, adjustedY + adjustedSize);
                context.lineTo(adjustedX + adjustedSize, adjustedY);
                context.stroke();
            }

            startGame() {
                let virtualStage = new Array(this.stageWidth);
                for (let i = 0; i < this.stageWidth; i++) {
                    virtualStage[i] = new Array(this.stageHeight).fill(null);
                }
                this.virtualStage = virtualStage;
                this.currentBlock = null;
                this.nextBlock = this.getRandomBlock();
                this.mainLoop();
            }

            mainLoop() {
                if (this.currentBlock == null) {
                    if (!this.createNewBlock()) {
                        return;
                    }
                } else {
                    this.fallBlock();
                }
                this.drawStage();
                if (this.currentBlock != null) {
                    this.drawBlock(this.stageLeftPadding + this.blockX * this.cellSize,
                        this.stageTopPadding + this.blockY * this.cellSize,
                        this.currentBlock, this.blockAngle, this.stageCanvas);
                }
                setTimeout(this.mainLoop.bind(this), 500);
            }

            createNewBlock() {
                this.currentBlock = this.nextBlock;
                this.nextBlock = this.getRandomBlock();
                this.blockX = Math.floor(this.stageWidth / 2 - 2);
                this.blockY = 0;
                this.blockAngle = 0;
                this.drawNextBlock();
                if (!this.checkBlockMove(this.blockX, this.blockY, this.currentBlock, this.blockAngle)) {
                    let messageElem = document.getElementById("message");
                    messageElem.innerText = "GAME OVER";
                    return false;
                }
                return true;
            }

            drawNextBlock() {
                this.clear(this.nextCanvas);
                this.drawBlock(this.cellSize * 2, this.cellSize, this.nextBlock,
                    0, this.nextCanvas);
            }


            shuffleBlocks() {
                let blocks = [0, 1, 2, 3, 4, 5, 6];
                for (let i = blocks.length - 1; i > 0; i--) {
                    let j = Math.floor(Math.random() * (i + 1));
                    [blocks[i], blocks[j]] = [blocks[j], blocks[i]]; // Fisher-Yates Shuffle
                }
                return blocks;
            }

            getRandomBlock() {
                if (this.blockQueue.length === 0) {
                    this.blockQueue = this.shuffleBlocks(); // 모든 블록을 사용하면 다시 섞음
                }
                return this.blockQueue.pop(); // 순서대로 하나씩 반환
            }

            fallBlock() {
                if (this.checkBlockMove(this.blockX, this.blockY + 1, this.currentBlock, this.blockAngle)) {
                    this.blockY++;
                } else {
                    this.fixBlock(this.blockX, this.blockY, this.currentBlock, this.blockAngle);
                    this.currentBlock = null;
                }
            }

            checkBlockMove(x, y, type, angle) {
                for (let i = 0; i < this.blocks[type].shape[angle].length; i++) {
                    let cellX = x + this.blocks[type].shape[angle][i][0];
                    let cellY = y + this.blocks[type].shape[angle][i][1];
                    if (cellX < 0 || cellX > this.stageWidth - 1) {
                        return false;
                    }
                    if (cellY > this.stageHeight - 1) {
                        return false;
                    }
                    if (this.virtualStage[cellX][cellY] != null) {
                        return false;
                    }
                }
                return true;
            }

            fixBlock(x, y, type, angle) {
                for (let i = 0; i < this.blocks[type].shape[angle].length; i++) {
                    let cellX = x + this.blocks[type].shape[angle][i][0];
                    let cellY = y + this.blocks[type].shape[angle][i][1];
                    if (cellY >= 0) {
                        this.virtualStage[cellX][cellY] = type; // 블록을 가상 스테이지에 고정
                    }
                }

                let deletedThisTurn = 0; // 이번 턴에서 지운 줄 개수

                for (let y = this.stageHeight - 1; y >= 0; ) {  // 바닥부터 검사
                    let filled = true;
                    for (let x = 0; x < this.stageWidth; x++) {
                        if (this.virtualStage[x][y] == null) { // 한 줄에 빈 공간이 있으면 삭제하지 않음
                            filled = false;
                            break;
                        }
                    }
                    if (filled) { // 가득 찬 줄이 있다면 삭제 처리
                        deletedThisTurn++; // 이번 턴에서 삭제된 줄 증가

                        for (let y2 = y; y2 > 0; y2--) { // 한 줄씩 아래로 내림
                            for (let x = 0; x < this.stageWidth; x++) {
                                this.virtualStage[x][y2] = this.virtualStage[x][y2 - 1];
                            }
                        }
                        for (let x = 0; x < this.stageWidth; x++) { // 최상단은 빈 칸으로 초기화
                            this.virtualStage[x][0] = null;
                        }
                        let linesElem = document.getElementById("lines"); // UI 업데이트
                        this.deletedLines += 1; // 총 삭제된 줄 개수 증가
                        linesElem.innerText = "" + this.deletedLines;
                    } else {
                        y--; // 다음 줄 검사
                    }
                }

                if (deletedThisTurn > 0) {
                    console.log(socket)
                    socket.emit('line_deleted', deletedThisTurn, roomId);
                    console.log(`이 번 턴에서 ${deletedThisTurn}줄 삭제됨!`);
                }
            }
            drawStage() {
                this.clear(this.stageCanvas);

                let context = this.stageCanvas.getContext("2d");
                for (let x = 0; x < this.virtualStage.length; x++) {
                    for (let y = 0; y < this.virtualStage[x].length; y++) {
                        if (this.virtualStage[x][y] != null) {
                            this.drawCell(context,
                                this.stageLeftPadding + (x * this.cellSize),
                                this.stageTopPadding + (y * this.cellSize),
                                this.cellSize,
                                this.virtualStage[x][y]);
                        }
                    }
                }
            }

            moveLeft() {
                if (this.checkBlockMove(this.blockX - 1, this.blockY, this.currentBlock, this.blockAngle)) {
                    this.blockX--;
                    this.refreshStage();
                }
            }

            moveRight() {
                if (this.checkBlockMove(this.blockX + 1, this.blockY, this.currentBlock, this.blockAngle)) {
                    this.blockX++;
                    this.refreshStage();
                }
            }

            rotate() {
                let newAngle;
                if (this.blockAngle < 3) {
                    newAngle = this.blockAngle + 1;
                } else {
                    newAngle = 0;
                }
                if (this.checkBlockMove(this.blockX, this.blockY, this.currentBlock, newAngle)) {
                    this.blockAngle = newAngle;
                    this.refreshStage();
                }
            }

            fall() {
                while (this.checkBlockMove(this.blockX, this.blockY + 1, this.currentBlock, this.blockAngle)) {
                    this.blockY++;
                    this.refreshStage();
                }
            }

            refreshStage() {
                this.clear(this.stageCanvas);
                this.drawStage();
                this.drawBlock(this.stageLeftPadding + this.blockX * this.cellSize,
                    this.stageTopPadding + this.blockY * this.cellSize,
                    this.currentBlock, this.blockAngle, this.stageCanvas);
            }

            clear(canvas) {
                let context = canvas.getContext("2d");
                context.fillStyle = "rgb(0, 0, 0)";
                context.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        document.addEventListener("DOMContentLoaded", function () {
            var tetris = new Tetris();
            tetris.startGame();
        });

        socket.on('higher_gauge', (line_deleted)=>{
            player1_health= player1_health - line_deleted;
            player2_health= player2_health + line_deleted/2;
            setGauge("player1", player1_health);
            setGauge("player2", player2_health);
        });
        socket.on('lower_gauge', (line_deleted)=>{
            player1_health= player1_health + line_deleted/2;
            player2_health= player2_health - line_deleted;
            setGauge("player1", player1_health);
            setGauge("player2", player2_health);
        })
    }

    // 테트리스 시작

</script>

</body>
</html>
